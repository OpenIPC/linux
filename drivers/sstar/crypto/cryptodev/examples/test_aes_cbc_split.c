/*
 * Demo on how to use /dev/crypto device for ciphering.
 *
 * Placed under public domain.
 *
 */
#include <crypto/cryptodev.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include "aes.h"

#define KEY_SIZE 16

int aes_ctx_init(struct cryptodev_ctx *ctx, int cfd, const uint8_t *key, unsigned int key_size)
{
#ifdef CIOCGSESSINFO
    struct session_info_op siop;
#endif

    memset(ctx, 0, sizeof(*ctx));
    ctx->cfd = cfd;

    ctx->sess.cipher = CRYPTO_AES_CBC;
    ctx->sess.keylen = key_size;
    ctx->sess.key    = (void *)key;
    if (ioctl(ctx->cfd, CIOCGSESSION, &ctx->sess))
    {
        perror("ioctl(CIOCGSESSION)");
        return -1;
    }

#ifdef CIOCGSESSINFO
    memset(&siop, 0, sizeof(siop));

    siop.ses = ctx->sess.ses;
    if (ioctl(ctx->cfd, CIOCGSESSINFO, &siop))
    {
        perror("ioctl(CIOCGSESSINFO)");
        return -1;
    }
    printf("Got %s with driver %s\n", siop.cipher_info.cra_name, siop.cipher_info.cra_driver_name);
    if (!(siop.flags & SIOP_FLAG_KERNEL_DRIVER_ONLY))
    {
        printf("Note: This is not an accelerated cipher\n");
    }
    /*printf("Alignmask is %x\n", (unsigned int)siop.alignmask); */
    ctx->alignmask = siop.alignmask;
#endif
    return 0;
}

void aes_ctx_deinit(struct cryptodev_ctx *ctx)
{
    if (ioctl(ctx->cfd, CIOCFSESSION, &ctx->sess.ses))
    {
        perror("ioctl(CIOCFSESSION)");
    }
}

int aes_encrypt(struct cryptodev_ctx *ctx, const void *iv, const void *plaintext, void *ciphertext, size_t size)
{
    struct crypt_op cryp;
    void *          p;

    /* check plaintext and ciphertext alignment */
    if (ctx->alignmask)
    {
        p = (void *)(((unsigned long)plaintext + ctx->alignmask) & ~ctx->alignmask);
        if (plaintext != p)
        {
            fprintf(stderr, "plaintext is not aligned\n");
        }

        p = (void *)(((unsigned long)ciphertext + ctx->alignmask) & ~ctx->alignmask);
        if (ciphertext != p)
        {
            fprintf(stderr, "ciphertext is not aligned\n");
        }
    }

    memset(&cryp, 0, sizeof(cryp));

    /* Encrypt data.in to data.encrypted */
    cryp.ses   = ctx->sess.ses;
    cryp.len   = size;
    cryp.src   = (void *)plaintext;
    cryp.dst   = ciphertext;
    cryp.iv    = (void *)iv;
    cryp.op    = COP_ENCRYPT;
    cryp.flags = COP_FLAG_WRITE_IV;
    if (ioctl(ctx->cfd, CIOCCRYPT, &cryp))
    {
        perror("ioctl(CIOCCRYPT)");
        return -1;
    }

    return 0;
}

int aes_decrypt(struct cryptodev_ctx *ctx, const void *iv, const void *ciphertext, void *plaintext, size_t size)
{
    struct crypt_op cryp;
    void *          p;

    /* check plaintext and ciphertext alignment */
    if (ctx->alignmask)
    {
        p = (void *)(((unsigned long)plaintext + ctx->alignmask) & ~ctx->alignmask);
        if (plaintext != p)
        {
            fprintf(stderr, "plaintext is not aligned\n");
        }

        p = (void *)(((unsigned long)ciphertext + ctx->alignmask) & ~ctx->alignmask);
        if (ciphertext != p)
        {
            fprintf(stderr, "ciphertext is not aligned\n");
        }
    }

    memset(&cryp, 0, sizeof(cryp));

    /* Encrypt data.in to data.encrypted */
    cryp.ses   = ctx->sess.ses;
    cryp.len   = size;
    cryp.src   = (void *)ciphertext;
    cryp.dst   = plaintext;
    cryp.iv    = (void *)iv;
    cryp.op    = COP_DECRYPT;
    cryp.flags = COP_FLAG_WRITE_IV;

    if (ioctl(ctx->cfd, CIOCCRYPT, &cryp))
    {
        perror("ioctl(CIOCCRYPT)");
        return -1;
    }

    return 0;
}

#define DATA_SIZE 512
char plaintext[DATA_SIZE];
char enc_gold[DATA_SIZE] = {
    0x57, 0xf0, 0x20, 0x3b, 0xfa, 0x75, 0x9a, 0xe7, 0x43, 0xc0, 0xe3, 0x7d, 0xc2, 0xae, 0x88, 0x68, 0x35, 0x49, 0x2a,
    0x34, 0xc5, 0xbe, 0xf7, 0x55, 0x64, 0x35, 0x1e, 0x8b, 0x39, 0x4d, 0x8c, 0x6e, 0xeb, 0x30, 0x9b, 0x65, 0xbf, 0xc7,
    0x99, 0x86, 0x29, 0xe5, 0xb8, 0x46, 0x2a, 0x71, 0xc6, 0x2b, 0xc7, 0x02, 0x04, 0x48, 0x0b, 0xb2, 0x01, 0xb0, 0xf5,
    0x58, 0x3c, 0x7b, 0x81, 0xfc, 0xc6, 0xf6, 0x72, 0xd7, 0x29, 0x5e, 0x2b, 0xf4, 0x01, 0x93, 0x13, 0xc7, 0x53, 0x64,
    0x02, 0x5c, 0x68, 0x7f, 0x3a, 0x01, 0x4f, 0x81, 0x67, 0xf6, 0x85, 0x42, 0x4c, 0x95, 0x0f, 0x14, 0xaf, 0x55, 0xd4,
    0xca, 0x80, 0x76, 0x14, 0x9b, 0x64, 0xd8, 0x61, 0x44, 0x69, 0xde, 0xa7, 0xb8, 0x1c, 0x03, 0x78, 0x2a, 0xb5, 0xe1,
    0xd2, 0x39, 0x41, 0x65, 0xe2, 0x13, 0x9b, 0x8c, 0xcf, 0x9c, 0xae, 0x9f, 0x3b, 0x45, 0xda, 0x77, 0x96, 0x3e, 0x72,
    0x4e, 0x75, 0x12, 0x4e, 0x5c, 0x5e, 0x76, 0x81, 0xf4, 0xf2, 0x9e, 0xc7, 0x67, 0x4b, 0x43, 0x4e, 0x8f, 0x71, 0x9b,
    0xc6, 0x64, 0x0b, 0x8b, 0xef, 0xca, 0xad, 0x5b, 0xe3, 0x4e, 0xb1, 0x9a, 0x4f, 0x8d, 0xcf, 0x33, 0x03, 0x0d, 0x83,
    0xf2, 0x36, 0x45, 0x20, 0x4a, 0x59, 0x36, 0x62, 0x89, 0x60, 0xc1, 0x28, 0x7b, 0xbf, 0xdf, 0xb9, 0xa2, 0x63, 0xdf,
    0x88, 0xde, 0x84, 0x2c, 0x87, 0x41, 0x0b, 0xde, 0xa1, 0x6c, 0x3e, 0xc6, 0xa3, 0x37, 0x21, 0xc0, 0x74, 0x11, 0x65,
    0x3c, 0xa7, 0x71, 0xb8, 0x97, 0xab, 0x95, 0x9c, 0xee, 0x03, 0x7f, 0x8b, 0xa9, 0x62, 0x3f, 0x7f, 0xfe, 0x5a, 0x45,
    0x80, 0x9a, 0x66, 0xb9, 0xaf, 0x57, 0xf0, 0xf3, 0xe5, 0x49, 0xdb, 0x34, 0xc3, 0x93, 0x1e, 0x61, 0x91, 0x72, 0x2d,
    0x25, 0xbf, 0x3b, 0xe2, 0x8b, 0xdd, 0x53, 0xe8, 0xbc, 0x8a, 0xcd, 0x48, 0xd2, 0x75, 0x4a, 0x77, 0xc1, 0x40, 0x74,
    0xb7, 0x4b, 0x83, 0x7b, 0x67, 0xd9, 0x23, 0xc1, 0xc5, 0x7a, 0x6f, 0x63, 0xaf, 0xcf, 0xd9, 0xe1, 0x67, 0xbe, 0x57,
    0xe2, 0xa3, 0x27, 0xa0, 0x78, 0xab, 0xff, 0xef, 0xc7, 0xed, 0x93, 0x99, 0x2a, 0xfa, 0xb0, 0xc9, 0x41, 0x62, 0xd1,
    0x70, 0x29, 0x8b, 0x00, 0x95, 0x8f, 0x6c, 0xa7, 0xeb, 0xe6, 0xb2, 0xd9, 0x5f, 0x5b, 0xff, 0xd0, 0xf0, 0x5a, 0xac,
    0xc0, 0x75, 0x3e, 0xc8, 0xab, 0x90, 0xb7, 0x3f, 0x46, 0x2d, 0xd6, 0x75, 0x24, 0xd4, 0x5e, 0x5a, 0x72, 0x3b, 0x67,
    0xfe, 0xde, 0xe0, 0xf5, 0x3a, 0xf9, 0x04, 0xbd, 0x57, 0xe7, 0x9d, 0x83, 0x2b, 0xea, 0xd1, 0x8a, 0x3e, 0xb2, 0x51,
    0x98, 0xac, 0x85, 0x08, 0x16, 0xe3, 0xd1, 0xa3, 0x86, 0xc7, 0x98, 0xd2, 0x12, 0xcb, 0xc9, 0x88, 0xf4, 0xe1, 0xf1,
    0x42, 0x3b, 0xef, 0x79, 0x4a, 0xe4, 0x53, 0x12, 0x8b, 0x94, 0x05, 0x38, 0xba, 0x90, 0x62, 0x98, 0x03, 0x32, 0x02,
    0x97, 0x8a, 0xda, 0x29, 0xf7, 0xd9, 0x17, 0x01, 0x10, 0xba, 0x84, 0xda, 0xb2, 0x67, 0xf6, 0xa3, 0xa4, 0x3d, 0x5b,
    0x05, 0x9e, 0x1d, 0xe4, 0xa6, 0x4a, 0x82, 0xc7, 0x10, 0x13, 0x98, 0x36, 0xa7, 0xe0, 0xdb, 0x9b, 0xa0, 0xa5, 0xaa,
    0xdd, 0x77, 0x91, 0xce, 0xa7, 0xe9, 0xda, 0x11, 0x5c, 0x9c, 0x2c, 0x96, 0x63, 0x6a, 0xb7, 0xba, 0x65, 0x4b, 0xe1,
    0xce, 0xae, 0xe6, 0x64, 0xbc, 0x80, 0x57, 0x7d, 0x52, 0x50, 0x2b, 0xa4, 0x2d, 0xa0, 0x5e, 0x90, 0x5e, 0x4e, 0x4e,
    0xee, 0xff, 0x26, 0xc7, 0x1c, 0x28, 0x7a, 0x52, 0x1f, 0xc4, 0x8b, 0xfe, 0x9f, 0x17, 0x20, 0x5e, 0x1d, 0x13, 0x1b,
    0x93, 0x0f, 0x7b, 0x2c, 0x30, 0x15, 0x85, 0x6c, 0x48, 0x44, 0xdd, 0x05, 0x85, 0x6e, 0x49, 0xcf, 0xa1, 0x29};
uint8_t key[KEY_SIZE]          = {0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88,
                         0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x00};
char    iv[AES_BLOCK_SIZE]     = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
                           0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
char    enc_result[DATA_SIZE]  = {0};
char    dec_result[DATA_SIZE]  = {0};
char    iv_ctx[AES_BLOCK_SIZE] = {0};

static int test_aes(int cfd)
{
    struct cryptodev_ctx ctx;
    int                  iv_cnt;

    // init plaintext 512*0x5a
    memset(plaintext, 0x5a, DATA_SIZE);
    /* Test 1 */
    aes_ctx_init(&ctx, cfd, key, sizeof(key));
    printf("test encrypt iv start\n");

    memcpy(iv_ctx, iv, AES_BLOCK_SIZE);
    aes_encrypt(&ctx, iv_ctx, plaintext, enc_result, DATA_SIZE / 4);
    printf("enc_iv:\n");
    for (iv_cnt = 0; iv_cnt < 16; iv_cnt++)
    {
        printf("%02x ", iv_ctx[iv_cnt]);
    }
    printf("\n");

    aes_encrypt(&ctx, iv_ctx, plaintext + DATA_SIZE / 4, enc_result + DATA_SIZE / 4, DATA_SIZE / 4);
    printf("enc_iv:\n");
    for (iv_cnt = 0; iv_cnt < 16; iv_cnt++)
    {
        printf("%02x ", iv_ctx[iv_cnt]);
    }
    printf("\n");

    aes_encrypt(&ctx, iv_ctx, plaintext + 2 * DATA_SIZE / 4, enc_result + 2 * DATA_SIZE / 4, DATA_SIZE / 4);
    printf("enc_iv:\n");
    for (iv_cnt = 0; iv_cnt < 16; iv_cnt++)
    {
        printf("%02x ", iv_ctx[iv_cnt]);
    }
    printf("\n");

    aes_encrypt(&ctx, iv_ctx, plaintext + 3 * DATA_SIZE / 4, enc_result + 3 * DATA_SIZE / 4, DATA_SIZE / 4);
    printf("enc_iv:\n");
    for (iv_cnt = 0; iv_cnt < 16; iv_cnt++)
    {
        printf("%02x ", iv_ctx[iv_cnt]);
    }
    printf("\n");

    if (memcmp(enc_result, enc_gold, DATA_SIZE) != 0)
    {
        fprintf(stderr, "FAIL: encrypt iv  incorrect.\n");
    }
    else
    {
        printf("test encrypt pass\n");
    }

    /* Verify iv */
    // The iv when encrypted is equal to the last sixteen bytes of dst data
    // if (memcmp(iv1, ciphertext1, AES_BLOCK_SIZE) != 0)
    // {
    //     fprintf(stderr, "FAIL: encrypt iv is incorrect.\n");
    // }
    // else {
    //     printf("test encrypt iv pass\n");
    // }

    aes_ctx_deinit(&ctx);

    return 0;
}

int main()
{
    int cfd = -1;

    /* Open the crypto device */
    cfd = open("/dev/crypto", O_RDWR, 0);
    if (cfd < 0)
    {
        perror("open(/dev/crypto)");
        return 1;
    }

    /* Set close-on-exec (not really neede here) */
    if (fcntl(cfd, F_SETFD, 1) == -1)
    {
        perror("fcntl(F_SETFD)");
        return 1;
    }

    /* Run the test itself */
    if (test_aes(cfd))
        return 1;

    /* Close the original descriptor */
    if (close(cfd))
    {
        perror("close(cfd)");
        return 1;
    }

    return 0;
}
